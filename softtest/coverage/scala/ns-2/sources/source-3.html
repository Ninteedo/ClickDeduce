


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > AbstractNodeLanguage</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">languages</a>
</div>

<h1>Coverage Summary for Class: AbstractNodeLanguage (languages)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AbstractNodeLanguage</td>
<td class="coverageStat">
  <span class="percent">
    78.3%
  </span>
  <span class="absValue">
    (47/60)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    79.6%
  </span>
  <span class="absValue">
    (78/98)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AbstractNodeLanguage$$anon$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$$anon$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$$anon$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$BlankExprDropDown</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$BlankExprDropDown$</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$BlankSpace</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$BlankTypeDropDown</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$BlankTypeDropDown$</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$DepthLimitExceededException</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$ExprChoiceNode</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$ExprChoiceNode$</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$ExprNode</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (33/33)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.7%
  </span>
  <span class="absValue">
    (128/131)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$InnerNode</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$InnerNodeCannotBeRootException</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$InvalidTreePathException</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$InvalidTreePathStringException</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$LiteralNode</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$LiteralNode$</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$Node</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (14/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$Node$</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.1%
  </span>
  <span class="absValue">
    (27/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$NodeParentNotInitialisedException</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$NodeParentWrongTypeException</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$NodeParser$2$</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (12/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.4%
  </span>
  <span class="absValue">
    (27/32)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$NodeStringParseException</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$OuterNode</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (10/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.2%
  </span>
  <span class="absValue">
    (48/57)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$SubExprNode</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (10/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$SubExprNode$</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$SubTypeNode</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$SubTypeNode$</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$TermParser$2$</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.7%
  </span>
  <span class="absValue">
    (11/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$TypeChoiceNode</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$TypeChoiceNode$</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$TypeNode</td>
<td class="coverageStat">
  <span class="percent">
    69.2%
  </span>
  <span class="absValue">
    (9/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58.1%
  </span>
  <span class="absValue">
    (18/31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$TypeNode$</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.3%
  </span>
  <span class="absValue">
    (28/31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$TypeNodeParent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (19/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$VariableNode</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (39/39)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractNodeLanguage$VariableNode$</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.1%
  </span>
  <span class="absValue">
    (32/34)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    90.4%
  </span>
  <span class="absValue">
    (207/229)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89.2%
  </span>
  <span class="absValue">
    (531/595)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package languages
&nbsp;
&nbsp;import app.UtilityFunctions
&nbsp;import scalatags.Text.TypedTag
&nbsp;import scalatags.Text.all.*
&nbsp;
&nbsp;import scala.annotation.tailrec
&nbsp;import scala.util.parsing.combinator.*
&nbsp;
<b class="fc">&nbsp;trait AbstractNodeLanguage extends AbstractLanguage {</b>
&nbsp;  lang =&gt;
&nbsp;
<b class="fc">&nbsp;  trait BlankSpace extends Term {</b>
&nbsp;    override lazy val toHtml: TypedTag[String] = {
<b class="nc">&nbsp;      input(`type` := &quot;text&quot;, placeholder := &quot;Term&quot;)</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="pc">&nbsp;  case class BlankExprDropDown() extends Expr, BlankSpace {</b>
<b class="fc">&nbsp;    override lazy val toHtml: TypedTag[String] = exprClassListDropdownHtml</b>
&nbsp;  }
&nbsp;
<b class="pc">&nbsp;  case class BlankTypeDropDown() extends Type, BlankSpace {</b>
<b class="fc">&nbsp;    override lazy val toHtml: TypedTag[String] = typeClassListDropdownHtml</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  private lazy val exprClassList: List[Class[Expr]] = calculateExprClassList</b>
&nbsp;
&nbsp;  protected def calculateExprClassList: List[Class[Expr]]
&nbsp;
<b class="fc">&nbsp;  private lazy val typeClassList: List[Class[Type]] = calculateTypeClassList</b>
&nbsp;
<b class="fc">&nbsp;  protected def calculateTypeClassList: List[Class[Type]] = List(classOf[UnknownType]).map(_.asInstanceOf[Class[Type]])</b>
&nbsp;
&nbsp;  private lazy val blankClassList: List[Class[BlankSpace]] =
<b class="fc">&nbsp;    List(classOf[BlankExprDropDown], classOf[BlankTypeDropDown]).map(_.asInstanceOf[Class[BlankSpace]])</b>
&nbsp;
<b class="fc">&nbsp;  private lazy val nodeClassList: List[Class[Node]] = List(</b>
<b class="fc">&nbsp;    classOf[VariableNode],</b>
&nbsp;    classOf[ExprChoiceNode],
&nbsp;    classOf[SubExprNode],
&nbsp;    classOf[LiteralNode],
&nbsp;    classOf[TypeNode],
&nbsp;    classOf[TypeChoiceNode],
<b class="fc">&nbsp;    classOf[SubTypeNode]</b>
<b class="fc">&nbsp;  ).map(_.asInstanceOf[Class[Node]])</b>
&nbsp;
<b class="fc">&nbsp;  private lazy val exprClassListDropdownHtml: TypedTag[String] = select(</b>
<b class="fc">&nbsp;    cls := &quot;expr-dropdown&quot;,</b>
<b class="fc">&nbsp;    option(value := &quot;&quot;, &quot;Select Expr...&quot;),</b>
<b class="fc">&nbsp;    exprClassList.map(e =&gt; {</b>
<b class="fc">&nbsp;      option(value := e.getSimpleName, e.getSimpleName)</b>
<b class="fc">&nbsp;    })</b>
&nbsp;  )
&nbsp;
<b class="fc">&nbsp;  private lazy val typeClassListDropdownHtml: TypedTag[String] = select(</b>
<b class="fc">&nbsp;    cls := &quot;type-dropdown&quot;,</b>
<b class="fc">&nbsp;    option(value := &quot;&quot;, &quot;Select Type...&quot;),</b>
<b class="fc">&nbsp;    typeClassList.map(e =&gt; {</b>
<b class="fc">&nbsp;      option(value := e.getSimpleName, e.getSimpleName)</b>
<b class="fc">&nbsp;    })</b>
&nbsp;  )
&nbsp;
&nbsp;  /** Create an `Term` given its string representation.
&nbsp;    *
&nbsp;    * @return
&nbsp;    *   The `Term` created, if successful.
&nbsp;    */
&nbsp;  private def parseTerm(s: String): Option[Term] = {
&nbsp;    @tailrec
&nbsp;    def makeTerm(name: String, args: List[Any]): Option[Term] = {
&nbsp;      def constructTermFromArgs[T](termClass: Class[T]): T = {
<b class="fc">&nbsp;        val constructor = termClass.getConstructors()(0)</b>
<b class="fc">&nbsp;        val arguments = this +: args.map {</b>
<b class="fc">&nbsp;          case Some(e) =&gt; e</b>
<b class="fc">&nbsp;          case x       =&gt; x</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        constructor.newInstance(arguments: _*).asInstanceOf[T]</b>
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      val exprClass = exprClassList.find(_.getSimpleName == name)</b>
<b class="fc">&nbsp;      exprClass match {</b>
<b class="fc">&nbsp;        case Some(value) =&gt; Some(constructTermFromArgs(value))</b>
<b class="fc">&nbsp;        case None =&gt;</b>
<b class="fc">&nbsp;          val blankClass = blankClassList.find(_.getSimpleName == name)</b>
<b class="fc">&nbsp;          blankClass match {</b>
<b class="fc">&nbsp;            case Some(value) =&gt; makeTerm(&quot;MissingExpr&quot;, Nil)</b>
<b class="fc">&nbsp;            case None =&gt;</b>
<b class="fc">&nbsp;              typeClassList.find(_.getSimpleName == name) match {</b>
<b class="fc">&nbsp;                case Some(value) =&gt; Some(constructTermFromArgs(value))</b>
<b class="nc">&nbsp;                case None        =&gt; None</b>
<b class="nc">&nbsp;              }</b>
<b class="nc">&nbsp;          }</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    object TermParser extends JavaTokenParsers {</b>
<b class="fc">&nbsp;      def term: Parser[Option[Term]] = name ~ &quot;(&quot; ~ repsep(arg, &quot;\\s*,\\s*&quot;.r) ~ &quot;)&quot; ^^ {</b>
<b class="fc">&nbsp;        case name ~ &quot;(&quot; ~ args ~ &quot;)&quot; =&gt; makeTerm(name, args)</b>
<b class="nc">&nbsp;        case _                       =&gt; None</b>
<b class="fc">&nbsp;      }</b>
&nbsp;
<b class="fc">&nbsp;      def name: Parser[String] = &quot;[A-Za-z]\\w*&quot;.r</b>
&nbsp;
<b class="fc">&nbsp;      def identifier: Parser[String] = &quot;[A-Za-z_$][\\w_$]*&quot;.r</b>
&nbsp;
<b class="fc">&nbsp;      def arg: Parser[Any] = term | stringLiteral ^^ (s =&gt; LiteralString(s)) |</b>
<b class="fc">&nbsp;        wholeNumber ^^ (n =&gt; LiteralInt(BigInt(n))) |</b>
<b class="fc">&nbsp;        &quot;true&quot; ^^ (_ =&gt; LiteralBool(true)) | &quot;false&quot; ^^ (_ =&gt; LiteralBool(false)) |</b>
<b class="fc">&nbsp;        identifier ^^ (s =&gt; LiteralIdentifier(s))</b>
&nbsp;
<b class="fc">&nbsp;      def parseTerm(s: String): ParseResult[Option[Term]] = parseAll(term, s.strip())</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    TermParser.parseTerm(s) match {</b>
<b class="fc">&nbsp;      case TermParser.Success(matched, _) =&gt; matched</b>
<b class="nc">&nbsp;      case x =&gt;</b>
<b class="nc">&nbsp;        None</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /** Function to load an `Expr` from a string. Input must be in the format produced by `Expr.toString`
&nbsp;    *
&nbsp;    * @param s
&nbsp;    *   The string to be parsed.
&nbsp;    * @return
&nbsp;    *   The `Expr` represented by the string, if successful.
&nbsp;    */
<b class="fc">&nbsp;  def readExpr(s: String): Option[Expr] = parseTerm(s) match {</b>
<b class="fc">&nbsp;    case Some(e: Expr) =&gt; Some(e)</b>
<b class="nc">&nbsp;    case _             =&gt; None</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  def readType(s: String): Option[Type] = parseTerm(s) match {</b>
<b class="fc">&nbsp;    case Some(t: Type) =&gt; Some(t)</b>
<b class="nc">&nbsp;    case _             =&gt; None</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  private def exprNameToClass(name: String): Option[Class[Expr]] = exprClassList.find(_.getSimpleName == name)</b>
&nbsp;
<b class="fc">&nbsp;  private def typeNameToClass(name: String): Option[Class[Type]] = typeClassList.find(_.getSimpleName == name)</b>
&nbsp;
<b class="fc">&nbsp;  private def cacheQuery[A, B](cache: collection.mutable.Map[A, B], key: A, value: =&gt; B): B = cache.get(key) match {</b>
<b class="fc">&nbsp;    case Some(value) =&gt; value</b>
<b class="fc">&nbsp;    case None =&gt;</b>
<b class="fc">&nbsp;      val result = value</b>
<b class="fc">&nbsp;      cache += (key -&gt; result)</b>
<b class="fc">&nbsp;      result</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  abstract class Node {</b>
<b class="fc">&nbsp;    val children: List[OuterNode] = Nil</b>
&nbsp;
<b class="fc">&nbsp;    private var parent: Option[Option[OuterNode]] = None</b>
&nbsp;
<b class="fc">&nbsp;    private var parentInitialised = false</b>
&nbsp;
<b class="fc">&nbsp;    def getParent: Option[OuterNode] = parent match {</b>
<b class="fc">&nbsp;      case Some(value) =&gt; value</b>
<b class="nc">&nbsp;      case None        =&gt; throw new NodeParentNotInitialisedException()</b>
&nbsp;    }
&nbsp;
&nbsp;    def setParent(parentNode: Option[OuterNode]): Unit = {
<b class="fc">&nbsp;      parent = Some(parentNode)</b>
<b class="fc">&nbsp;      markParentInitialised()</b>
&nbsp;    }
&nbsp;
&nbsp;    private def markParentInitialised(): Unit = {
<b class="fc">&nbsp;      parentInitialised = true</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    def isParentInitialised: Boolean = parentInitialised</b>
&nbsp;
&nbsp;    def toHtmlLine(mode: DisplayMode): TypedTag[String]
&nbsp;
&nbsp;    def toHtmlLineReadOnly(mode: DisplayMode): TypedTag[String]
&nbsp;
<b class="fc">&nbsp;    lazy val treePath: List[Int] = getParent match {</b>
<b class="fc">&nbsp;      case Some(value) =&gt; value.treePath :+ value.args.indexWhere(_ eq this)</b>
<b class="fc">&nbsp;      case None        =&gt; Nil</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    lazy val treePathString: String = treePath.mkString(&quot;-&quot;)</b>
&nbsp;  }
&nbsp;
<b class="pc">&nbsp;  object Node {</b>
<b class="fc">&nbsp;    val innerNodeClasses: List[Class[_ &lt;: Object]] =</b>
<b class="fc">&nbsp;      List(ExprChoiceNode.getClass, SubExprNode.getClass, LiteralNode.getClass)</b>
&nbsp;
<b class="fc">&nbsp;    val outerNodeClasses: List[Class[_ &lt;: Object]] = List(VariableNode.getClass)</b>
&nbsp;
&nbsp;    def read(s: String): Option[Node] = {
<b class="fc">&nbsp;      def makeNode(name: String, args: List[Any], env: Env | TypeEnv = Map()): Option[Node] = {</b>
<b class="fc">&nbsp;        val nodeClass = nodeClassList.find(_.getSimpleName == name)</b>
<b class="fc">&nbsp;        nodeClass match {</b>
<b class="fc">&nbsp;          case Some(value) =&gt;</b>
<b class="fc">&nbsp;            val constructor = value.getConstructors()(0)</b>
<b class="fc">&nbsp;            var arguments = AbstractNodeLanguage.this +: args.map {</b>
<b class="fc">&nbsp;              case l: Literal =&gt; l.toString</b>
<b class="fc">&nbsp;              case Some(e)    =&gt; e</b>
<b class="fc">&nbsp;              case x          =&gt; x</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            if (constructor.getParameterTypes.last.isAssignableFrom(classOf[Env])) {</b>
<b class="nc">&nbsp;              arguments = arguments :+ env</b>
&nbsp;            }
<b class="fc">&nbsp;            if (constructor.getParameterTypes.length != arguments.length) {</b>
<b class="fc">&nbsp;              throw new NodeStringParseException(s&quot;$name(${args.mkString(&quot;, &quot;)})&quot;)</b>
&nbsp;            }
<b class="fc">&nbsp;            Some(constructor.newInstance(arguments: _*).asInstanceOf[Node])</b>
<b class="nc">&nbsp;          case None =&gt; None</b>
&nbsp;        }
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      object NodeParser extends JavaTokenParsers {</b>
&nbsp;        def outerNode: Parser[Option[OuterNode | Expr | Type]] =
<b class="fc">&nbsp;          outerNodeName ~ &quot;(&quot; ~ repsep(outerNodeArg, &quot;\\s*,\\s*&quot;.r) ~ &quot;)&quot; ^^ {</b>
<b class="fc">&nbsp;            case name ~ &quot;(&quot; ~ args ~ &quot;)&quot; =&gt;</b>
<b class="fc">&nbsp;              val node = makeNode(name, args)</b>
<b class="fc">&nbsp;              node match {</b>
<b class="fc">&nbsp;                case Some(n: OuterNode) =&gt;</b>
<b class="fc">&nbsp;                  n.children.foreach(_.setParent(Some(n)))</b>
<b class="fc">&nbsp;                  Some(n)</b>
<b class="nc">&nbsp;                case _ =&gt; throw new NodeStringParseException(s&quot;$name(${args.mkString(&quot;, &quot;)})&quot;)</b>
&nbsp;              }
<b class="nc">&nbsp;            case _ =&gt; None</b>
<b class="fc">&nbsp;          }</b>
&nbsp;
<b class="nc">&nbsp;        def name: Parser[String] = &quot;[A-Za-z]\\w*&quot;.r</b>
&nbsp;
&nbsp;        def outerListParse: Parser[List[Any]] =
<b class="pc">&nbsp;          &quot;Nil&quot; ^^ { _ =&gt; Nil } | &quot;List(&quot; ~ repsep(outerNodeArg, &quot;\\s*,\\s*&quot;.r) ~ &quot;)&quot; ^^ { case _ ~ args ~ _ =&gt;</b>
<b class="fc">&nbsp;            args.filter(_ != None).map {</b>
<b class="fc">&nbsp;              case Some(e) =&gt; e</b>
<b class="fc">&nbsp;              case x       =&gt; x</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;          }</b>
&nbsp;
<b class="fc">&nbsp;        def outerNodeName: Parser[String] = &quot;ExprChoiceNode&quot; | &quot;VariableNode&quot; | &quot;TypeChoiceNode&quot; | &quot;TypeNode&quot;</b>
&nbsp;
<b class="fc">&nbsp;        def innerNodeName: Parser[String] = &quot;SubExprNode&quot; | &quot;LiteralNode&quot; | &quot;SubTypeNode&quot;</b>
&nbsp;
&nbsp;        def outerNodeArg: Parser[Any] =
<b class="fc">&nbsp;          outerListParse | innerNode | stringLiteral ^^ (s =&gt; Literal.fromString(UtilityFunctions.unquote(s)))</b>
&nbsp;
<b class="fc">&nbsp;        def innerNodeArg: Parser[Any] = outerNode | stringLiteral ^^ (s =&gt; {</b>
<b class="fc">&nbsp;          val temp = s</b>
<b class="fc">&nbsp;          Literal.fromString(UtilityFunctions.unquote(s))</b>
<b class="fc">&nbsp;        })</b>
&nbsp;
<b class="fc">&nbsp;        def innerNode: Parser[InnerNode] = innerNodeName ~ &quot;(&quot; ~ repsep(innerNodeArg, &quot;\\s*,\\s*&quot;.r) ~ &quot;)&quot; ^^ {</b>
<b class="fc">&nbsp;          case name ~ &quot;(&quot; ~ args ~ &quot;)&quot; =&gt;</b>
<b class="fc">&nbsp;            val node = makeNode(name, args)</b>
<b class="fc">&nbsp;            node match {</b>
<b class="fc">&nbsp;              case Some(n: InnerNode) =&gt; n</b>
<b class="nc">&nbsp;              case _                  =&gt; throw new NodeStringParseException(s&quot;$name(${args.mkString(&quot;, &quot;)})&quot;)</b>
&nbsp;            }
<b class="nc">&nbsp;          case other =&gt; throw new NodeStringParseException(other.toString)</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        def parseNode(s: String): ParseResult[Option[Node | Expr | Type]] = parseAll(outerNode, s.strip())</b>
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      NodeParser.parseNode(s) match {</b>
<b class="fc">&nbsp;        case NodeParser.Success(Some(matched: Node), _) =&gt; Some(matched)</b>
<b class="fc">&nbsp;        case x                                          =&gt; None</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    def readPathString(s: String): List[Int] = s match {</b>
<b class="fc">&nbsp;      case &quot;&quot; =&gt; Nil</b>
<b class="fc">&nbsp;      case s =&gt;</b>
<b class="fc">&nbsp;        if (s.split(&quot;-&quot;).forall(_.matches(&quot;\\d+&quot;))) s.split(&quot;-&quot;).map(_.toInt).toList</b>
<b class="fc">&nbsp;        else throw new InvalidTreePathStringException(s)</b>
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  abstract class OuterNode extends Node {</b>
&nbsp;    val args: List[InnerNode]
&nbsp;
&nbsp;    def markRoot(): Unit = {
<b class="fc">&nbsp;      setParent(None)</b>
&nbsp;    }
&nbsp;
&nbsp;    def toHtml(mode: DisplayMode): TypedTag[String] =
<b class="fc">&nbsp;      if (getVisibleChildren(mode).isEmpty) toHtmlAxiom(mode) else toHtmlSubtree(mode)</b>
&nbsp;
&nbsp;    def toHtmlAxiom(mode: DisplayMode): TypedTag[String]
&nbsp;
&nbsp;    def toHtmlSubtree(mode: DisplayMode): TypedTag[String]
&nbsp;
<b class="fc">&nbsp;    def getVisibleChildren(mode: DisplayMode): List[OuterNode] = children</b>
&nbsp;
&nbsp;    /** Find the child of this expression tree at the given path.
&nbsp;      *
&nbsp;      * @param path
&nbsp;      *   the path to the child
&nbsp;      * @return
&nbsp;      *   the child at the given path, if it exists
&nbsp;      */
<b class="fc">&nbsp;    def findChild(path: List[Int]): Option[Node] = path match {</b>
<b class="fc">&nbsp;      case Nil =&gt; Some(this)</b>
<b class="fc">&nbsp;      case head :: tail =&gt;</b>
<b class="fc">&nbsp;        if (!args.indices.contains(head)) throw new InvalidTreePathException(path)</b>
&nbsp;        else {
<b class="fc">&nbsp;          args(head) match {</b>
<b class="fc">&nbsp;            case SubExprNode(node) =&gt; node.findChild(tail)</b>
<b class="fc">&nbsp;            case SubTypeNode(node) =&gt; node.findChild(tail)</b>
<b class="fc">&nbsp;            case n: LiteralNode =&gt;</b>
<b class="fc">&nbsp;              tail match {</b>
<b class="fc">&nbsp;                case Nil =&gt; Some(n)</b>
<b class="nc">&nbsp;                case _   =&gt; throw new InvalidTreePathException(path)</b>
&nbsp;              }
<b class="nc">&nbsp;            case _ =&gt; None</b>
&nbsp;          }
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    def indexOf(node: Node): Int = node match {</b>
<b class="nc">&nbsp;      case n: InnerNode =&gt; args.indexWhere(_ eq n)</b>
<b class="nc">&nbsp;      case n: OuterNode =&gt; args.indexWhere(_.children.exists(_ eq n))</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    def replace(path: List[Int], replacement: Node): OuterNode = path match {</b>
<b class="fc">&nbsp;      case Nil =&gt;</b>
<b class="fc">&nbsp;        replacement match {</b>
<b class="fc">&nbsp;          case n: OuterNode =&gt; n</b>
&nbsp;        }
<b class="fc">&nbsp;      case head :: tail =&gt;</b>
<b class="fc">&nbsp;        val updatedArgs = args.updated(</b>
<b class="fc">&nbsp;          head,</b>
<b class="fc">&nbsp;          args(head) match {</b>
<b class="fc">&nbsp;            case SubExprNode(node) =&gt;</b>
<b class="fc">&nbsp;              SubExprNode(node.replace(tail, replacement) match {</b>
<b class="fc">&nbsp;                case n: ExprNode =&gt; n</b>
&nbsp;              })
<b class="fc">&nbsp;            case SubTypeNode(node) =&gt;</b>
<b class="fc">&nbsp;              SubTypeNode(node.replace(tail, replacement) match {</b>
<b class="fc">&nbsp;                case n: TypeNodeParent =&gt; n</b>
&nbsp;              })
<b class="fc">&nbsp;            case LiteralNode(literalText) =&gt;</b>
<b class="fc">&nbsp;              tail match {</b>
<b class="fc">&nbsp;                case Nil =&gt;</b>
<b class="fc">&nbsp;                  replacement match {</b>
<b class="fc">&nbsp;                    case n: InnerNode =&gt; n</b>
&nbsp;                  }
<b class="nc">&nbsp;                case _ =&gt; throw new InvalidTreePathException(path)</b>
<b class="nc">&nbsp;              }</b>
&nbsp;          }
&nbsp;        )
&nbsp;
<b class="fc">&nbsp;        this match {</b>
<b class="fc">&nbsp;          case VariableNode(exprName, _) =&gt; VariableNode(exprName, updatedArgs)</b>
<b class="fc">&nbsp;          case TypeNode(typeName, _)     =&gt; TypeNode(typeName, updatedArgs)</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    override lazy val treePath: List[Int] = getParent match {</b>
<b class="fc">&nbsp;      case Some(value) =&gt;</b>
<b class="fc">&nbsp;        val index: Int = value.args.indexWhere({</b>
<b class="fc">&nbsp;          case SubExprNode(node) =&gt; node eq this</b>
<b class="fc">&nbsp;          case SubTypeNode(node) =&gt; node eq this</b>
<b class="fc">&nbsp;          case _                 =&gt; false</b>
<b class="fc">&nbsp;        })</b>
<b class="fc">&nbsp;        if (index == -1) {</b>
<b class="fc">&nbsp;          if (isPhantom) Nil else throw new Exception(&quot;Could not find self in parent node&#39;s args&quot;)</b>
<b class="fc">&nbsp;        } else value.treePath :+ index</b>
<b class="fc">&nbsp;      case None =&gt; Nil</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    def isPhantom: Boolean = false</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  abstract class ExprNode extends OuterNode {</b>
<b class="fc">&nbsp;    override def setParent(parentNode: Option[OuterNode]): Unit = parentNode match {</b>
<b class="fc">&nbsp;      case Some(n: ExprNode) =&gt;</b>
<b class="fc">&nbsp;        val parentDepth = n.depth</b>
<b class="fc">&nbsp;        if (parentDepth &gt;= depthLimit) throw new DepthLimitExceededException()</b>
<b class="fc">&nbsp;        super.setParent(Some(n))</b>
<b class="fc">&nbsp;      case None    =&gt; super.setParent(None)</b>
<b class="nc">&nbsp;      case Some(n) =&gt; throw new NodeParentWrongTypeException(classOf[ExprNode], n.getClass)</b>
&nbsp;    }
&nbsp;
&nbsp;    override def getParent: Option[ExprNode] = {
<b class="fc">&nbsp;      if (!isParentInitialised) markRoot()</b>
<b class="fc">&nbsp;      super.getParent match {</b>
<b class="fc">&nbsp;        case Some(n: ExprNode) =&gt; Some(n)</b>
<b class="fc">&nbsp;        case None              =&gt; None</b>
<b class="nc">&nbsp;        case Some(n)           =&gt; throw new NodeParentWrongTypeException(classOf[ExprNode], n.getClass)</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    def depth: Int = getParent match {</b>
<b class="fc">&nbsp;      case Some(value) =&gt; value.depth + 1</b>
<b class="fc">&nbsp;      case None        =&gt; 0</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private def checkDepthLimitWillBeExceeded(currDepth: Int = 0): Unit = {</b>
<b class="fc">&nbsp;      if (currDepth + 1 &gt;= depthLimit) throw new DepthLimitExceededException()</b>
&nbsp;
<b class="fc">&nbsp;      getVisibleChildren(DisplayMode.Evaluation).foreach({</b>
<b class="fc">&nbsp;        case n: ExprNode =&gt; n.checkDepthLimitWillBeExceeded(currDepth + 1)</b>
&nbsp;        case _           =&gt;
<b class="fc">&nbsp;      })</b>
&nbsp;    }
&nbsp;
&nbsp;    val exprName: String
&nbsp;
&nbsp;    def getExpr: Expr
&nbsp;
<b class="fc">&nbsp;    lazy val getEditValueResult: Value = getExpr.eval(getEditEnv)</b>
&nbsp;
<b class="fc">&nbsp;    lazy val getValue: Value = getExpr.eval(getEvalEnv)</b>
&nbsp;
<b class="fc">&nbsp;    lazy val getType: Type = getExpr.typeCheck(getTypeEnv)</b>
&nbsp;
&nbsp;    private def getCorrectEnv[T](
&nbsp;      childrenFunction: Expr =&gt; Map[Variable, T] =&gt; List[(Term, Map[Variable, T])],
&nbsp;      parentEnvFunction: ExprNode =&gt; Map[Variable, T]
<b class="fc">&nbsp;    ): Map[Variable, T] = getParent match {</b>
<b class="fc">&nbsp;      case Some(value) =&gt;</b>
<b class="fc">&nbsp;        val parentEnv = parentEnvFunction(value)</b>
<b class="fc">&nbsp;        val parentExpr = value.getExpr</b>
<b class="fc">&nbsp;        val parentChildren = childrenFunction(parentExpr)(parentEnv)</b>
<b class="fc">&nbsp;        parentChildren.find(_._1 eq getExpr).map(_._2).getOrElse(parentEnv)</b>
<b class="fc">&nbsp;      case None =&gt; Map()</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    lazy val getEditEnv: Env = getCorrectEnv(_.getChildrenBase, _.getEditEnv)</b>
&nbsp;
<b class="fc">&nbsp;    lazy val getEvalEnv: Env = getCorrectEnv(_.getChildrenEval, _.getEvalEnv)</b>
&nbsp;
<b class="fc">&nbsp;    lazy val getTypeEnv: TypeEnv = getCorrectEnv(_.getChildrenTypeCheck, _.getTypeEnv)</b>
&nbsp;
&nbsp;    def toHtmlAxiom(mode: DisplayMode): TypedTag[String] = {
<b class="fc">&nbsp;      div(</b>
<b class="fc">&nbsp;        cls := &quot;subtree axiom&quot; + phantomClassName,</b>
<b class="fc">&nbsp;        data(&quot;tree-path&quot;) := treePathString,</b>
<b class="fc">&nbsp;        data(&quot;node-string&quot;) := toString,</b>
<b class="fc">&nbsp;        divByMode(mode, true),</b>
<b class="fc">&nbsp;        div(cls := &quot;annotation-axiom&quot;, exprName)</b>
&nbsp;      )
&nbsp;    }
&nbsp;
&nbsp;    def toHtmlSubtree(mode: DisplayMode): TypedTag[String] = {
<b class="fc">&nbsp;      if (mode == DisplayMode.Evaluation &amp;&amp; getParent.isEmpty) {</b>
&nbsp;        // check whether depth limit will be exceeded
<b class="fc">&nbsp;        checkDepthLimitWillBeExceeded()</b>
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      div(</b>
<b class="fc">&nbsp;        cls := &quot;subtree&quot; + phantomClassName,</b>
<b class="fc">&nbsp;        data(&quot;tree-path&quot;) := treePathString,</b>
<b class="fc">&nbsp;        data(&quot;node-string&quot;) := toString,</b>
<b class="fc">&nbsp;        divByMode(mode, false),</b>
<b class="fc">&nbsp;        div(cls := &quot;args&quot;, getVisibleChildren(mode).map(_.toHtml(mode)), div(cls := &quot;annotation-new&quot;, exprName))</b>
&nbsp;      )
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private val divByModeCache = collection.mutable.Map[(DisplayMode, Boolean), TypedTag[String]]()</b>
&nbsp;
<b class="fc">&nbsp;    private def divByMode(mode: DisplayMode, isAxiom: Boolean): TypedTag[String] = cacheQuery(</b>
<b class="fc">&nbsp;      divByModeCache,</b>
<b class="fc">&nbsp;      (mode, isAxiom),</b>
<b class="fc">&nbsp;      mode match {</b>
<b class="fc">&nbsp;        case DisplayMode.Edit       =&gt; editDiv(isAxiom)</b>
<b class="fc">&nbsp;        case DisplayMode.Evaluation =&gt; evalDiv(isAxiom)</b>
<b class="fc">&nbsp;        case DisplayMode.TypeCheck  =&gt; typeCheckDiv(isAxiom)</b>
&nbsp;      }
&nbsp;    )
&nbsp;
<b class="fc">&nbsp;    private def editDiv(isAxiom: Boolean): TypedTag[String] = div(</b>
<b class="fc">&nbsp;      cls := (if (isAxiom) &quot;expr&quot; else &quot;node&quot;),</b>
<b class="fc">&nbsp;      envDiv(DisplayMode.Edit),</b>
<b class="fc">&nbsp;      if (isAxiom)</b>
<b class="fc">&nbsp;        (if (!isPhantom) toHtmlLine(DisplayMode.Edit) else toHtmlLineReadOnly(DisplayMode.Edit)) (display := &quot;inline&quot;)</b>
<b class="fc">&nbsp;      else div(cls := &quot;expr&quot;, if (!isPhantom) toHtmlLine(DisplayMode.Edit) else toHtmlLineReadOnly(DisplayMode.Edit)), {</b>
<b class="fc">&nbsp;        val evalResult = getEditValueResult</b>
<b class="fc">&nbsp;        if (!evalResult.isError &amp;&amp; !evalResult.isPlaceholder) List(evalArrowSpan, editEvalResultDiv)</b>
<b class="fc">&nbsp;        else List(typeCheckTurnstileSpan, typeCheckResultDiv)</b>
&nbsp;      }
&nbsp;    )
&nbsp;
<b class="fc">&nbsp;    private def typeCheckDiv(isAxiom: Boolean): TypedTag[String] = div(</b>
<b class="fc">&nbsp;      cls := (if (isAxiom) &quot;expr&quot; else &quot;node&quot;),</b>
<b class="fc">&nbsp;      envDiv(DisplayMode.TypeCheck),</b>
<b class="fc">&nbsp;      if (isAxiom) toHtmlLine(DisplayMode.TypeCheck)(display := &quot;inline&quot;)</b>
<b class="fc">&nbsp;      else div(cls := &quot;expr&quot;, toHtmlLine(DisplayMode.TypeCheck)),</b>
<b class="fc">&nbsp;      typeCheckTurnstileSpan,</b>
<b class="fc">&nbsp;      typeCheckResultDiv</b>
&nbsp;    )
&nbsp;
<b class="fc">&nbsp;    private def evalDiv(isAxiom: Boolean): TypedTag[String] = div(</b>
<b class="fc">&nbsp;      cls := (if (isAxiom) &quot;expr&quot; else &quot;node&quot;),</b>
<b class="fc">&nbsp;      envDiv(DisplayMode.Evaluation),</b>
<b class="fc">&nbsp;      if (isAxiom) {</b>
<b class="fc">&nbsp;        (if (!isPhantom) toHtmlLine(DisplayMode.Evaluation) else toHtmlLineReadOnly(DisplayMode.Evaluation)) (</b>
<b class="fc">&nbsp;          display := &quot;inline&quot;</b>
&nbsp;        )
&nbsp;      } else {
<b class="fc">&nbsp;        div(</b>
<b class="fc">&nbsp;          cls := &quot;expr&quot;,</b>
<b class="fc">&nbsp;          if (!isPhantom) toHtmlLine(DisplayMode.Evaluation) else toHtmlLineReadOnly(DisplayMode.Evaluation)</b>
&nbsp;        )
&nbsp;      },
<b class="fc">&nbsp;      evalArrowSpan,</b>
<b class="fc">&nbsp;      evalResultDiv</b>
&nbsp;    )
&nbsp;
&nbsp;    private lazy val typeCheckTurnstileSpan: TypedTag[String] =
<b class="fc">&nbsp;      span(paddingLeft := &quot;0.5ch&quot;, paddingRight := &quot;0.5ch&quot;, raw(&quot;:&quot;))</b>
&nbsp;
&nbsp;    private lazy val typeCheckResultDiv: TypedTag[String] =
<b class="fc">&nbsp;      div(cls := &quot;type-check-result&quot;, display := &quot;inline&quot;, getType.toHtml)</b>
&nbsp;
&nbsp;    private lazy val evalArrowSpan: TypedTag[String] =
<b class="fc">&nbsp;      span(paddingLeft := &quot;1ch&quot;, paddingRight := &quot;1ch&quot;, raw(&quot;&amp;DoubleDownArrow;&quot;))</b>
&nbsp;
<b class="fc">&nbsp;    private lazy val evalResultDiv: TypedTag[String] = div(cls := &quot;eval-result&quot;, display := &quot;inline&quot;, getValue.toHtml)</b>
&nbsp;
&nbsp;    private lazy val editEvalResultDiv: TypedTag[String] =
<b class="fc">&nbsp;      div(cls := &quot;eval-result&quot;, display := &quot;inline&quot;, getEditValueResult.toHtml)</b>
&nbsp;
&nbsp;    private def envDiv(mode: DisplayMode): TypedTag[String] = {
<b class="fc">&nbsp;      val env: Env | TypeEnv = mode match {</b>
<b class="fc">&nbsp;        case DisplayMode.Edit       =&gt; getEditEnv</b>
<b class="fc">&nbsp;        case DisplayMode.Evaluation =&gt; getEvalEnv</b>
<b class="fc">&nbsp;        case DisplayMode.TypeCheck  =&gt; getTypeEnv</b>
&nbsp;      }
&nbsp;      val envHtml: String =
<b class="fc">&nbsp;        (if (env.nonEmpty)</b>
<b class="fc">&nbsp;           env.map((k: String, v: Value | Type) =&gt; s&quot;$k &amp;rarr; ${v.toHtml}&quot;).mkString(&quot;[&quot;, &quot;, &quot;, &quot;]&quot;)</b>
<b class="fc">&nbsp;         else &quot;&quot;) +</b>
<b class="fc">&nbsp;          (if (mode == DisplayMode.TypeCheck) &quot; &amp;#x22a2;&quot; else if (env.nonEmpty) &quot;,&quot; else &quot;&quot;)</b>
&nbsp;
<b class="fc">&nbsp;      div(</b>
<b class="fc">&nbsp;        cls := &quot;scoped-variables&quot;,</b>
<b class="fc">&nbsp;        display := &quot;inline&quot;,</b>
<b class="fc">&nbsp;        raw(envHtml),</b>
<b class="fc">&nbsp;        paddingRight := {</b>
<b class="fc">&nbsp;          if (envHtml.isEmpty) &quot;0ch&quot; else &quot;0.5ch&quot;</b>
<b class="fc">&nbsp;        }</b>
&nbsp;      )
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private val visibleChildrenCache = collection.mutable.Map[DisplayMode, List[OuterNode]]()</b>
&nbsp;
<b class="fc">&nbsp;    override def getVisibleChildren(mode: DisplayMode): List[OuterNode] = cacheQuery(</b>
<b class="fc">&nbsp;      visibleChildrenCache,</b>
<b class="fc">&nbsp;      mode,</b>
<b class="fc">&nbsp;      mode match {</b>
<b class="fc">&nbsp;        case DisplayMode.Edit      =&gt; children</b>
<b class="fc">&nbsp;        case DisplayMode.TypeCheck =&gt; children</b>
<b class="fc">&nbsp;        case DisplayMode.Evaluation =&gt;</b>
<b class="fc">&nbsp;          val childExprList = getExpr.getChildrenEval(getEvalEnv).map(_._1)</b>
<b class="fc">&nbsp;          var unconsumedChildren = children</b>
&nbsp;
<b class="fc">&nbsp;          childExprList.flatMap({ case expr: Expr =&gt;</b>
<b class="fc">&nbsp;            val matchingChild = unconsumedChildren.collectFirst {</b>
<b class="fc">&nbsp;              case c: ExprNode if c.getExpr eq expr                       =&gt; c</b>
<b class="fc">&nbsp;              case c: ExprChoiceNode if c.getExpr == expr &amp;&amp; !c.isPhantom =&gt; c</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            matchingChild match {</b>
<b class="fc">&nbsp;              case Some(childNode) =&gt;</b>
<b class="fc">&nbsp;                unconsumedChildren = unconsumedChildren.filter(_ ne childNode)</b>
<b class="fc">&nbsp;                Some(childNode)</b>
<b class="fc">&nbsp;              case None =&gt;</b>
<b class="fc">&nbsp;                val newNode = VariableNode.fromExpr(expr)</b>
<b class="fc">&nbsp;                newNode.setParent(Some(this))</b>
<b class="fc">&nbsp;                newNode.markPhantom()</b>
<b class="fc">&nbsp;                Some(newNode)</b>
<b class="nc">&nbsp;            }</b>
<b class="fc">&nbsp;          })</b>
&nbsp;      }
&nbsp;    )
&nbsp;
<b class="fc">&nbsp;    private var isPhantomStore = false</b>
&nbsp;
&nbsp;    private def markPhantom(): Unit = {
<b class="fc">&nbsp;      isPhantomStore = true</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    override def isPhantom: Boolean = isPhantomStore</b>
&nbsp;
<b class="fc">&nbsp;    private def phantomClassName: String = if (isPhantom) &quot; phantom&quot; else &quot;&quot;</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  case class VariableNode(exprName: String, args: List[InnerNode] = Nil) extends ExprNode {</b>
<b class="fc">&nbsp;    override val children: List[OuterNode] = args.flatMap(_.children)</b>
&nbsp;
<b class="fc">&nbsp;    override def getExpr: Expr = exprOverride.getOrElse(expr)</b>
&nbsp;
<b class="fc">&nbsp;    private var exprOverride: Option[Expr] = None</b>
&nbsp;
&nbsp;    def overrideExpr(e: Expr): Unit = {
<b class="fc">&nbsp;      exprOverride = Some(e)</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private lazy val exprClass: Class[Expr] = exprNameToClass(exprName) match {</b>
<b class="fc">&nbsp;      case Some(value) =&gt; value</b>
<b class="fc">&nbsp;      case None =&gt;</b>
<b class="fc">&nbsp;        throw new IllegalArgumentException(s&quot;Unknown expression type for ${lang.getClass.getSimpleName}: $exprName&quot;)</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    lazy val expr: Expr = {</b>
<b class="fc">&nbsp;      val constructor = exprClass.getConstructors.head</b>
<b class="fc">&nbsp;      val arguments = lang +: args.map {</b>
<b class="fc">&nbsp;        case n: SubExprNode =&gt; n.node.getExpr</b>
<b class="fc">&nbsp;        case n: LiteralNode =&gt; n.getLiteral</b>
<b class="fc">&nbsp;        case n: SubTypeNode =&gt; n.node.getType</b>
<b class="fc">&nbsp;      }</b>
<b class="fc">&nbsp;      constructor.newInstance(arguments: _*).asInstanceOf[Expr]</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    private val htmlLineCache = collection.mutable.Map[DisplayMode, TypedTag[String]]()</b>
<b class="fc">&nbsp;    private val htmlLineReadOnlyCache = collection.mutable.Map[DisplayMode, TypedTag[String]]()</b>
&nbsp;
&nbsp;    override def toHtmlLine(mode: DisplayMode): TypedTag[String] =
<b class="fc">&nbsp;      cacheQuery(htmlLineCache, mode, div(raw(getExprHtmlLine(mode))))</b>
&nbsp;
&nbsp;    override def toHtmlLineReadOnly(mode: DisplayMode): TypedTag[String] =
<b class="fc">&nbsp;      cacheQuery(htmlLineReadOnlyCache, mode, div(display := &quot;inline&quot;, raw(getExprHtmlLineReadOnly(mode))))</b>
&nbsp;
&nbsp;    private def getExprHtmlLine(mode: DisplayMode): String = {
<b class="fc">&nbsp;      val constructor = exprClass.getConstructors.head</b>
<b class="fc">&nbsp;      val arguments = lang +: args.map {</b>
<b class="fc">&nbsp;        case n: SubExprNode =&gt; ExprPlaceholder(n.toHtmlLineReadOnly(mode).toString)</b>
<b class="fc">&nbsp;        case n: LiteralNode =&gt; LiteralAny(n.toHtmlLine(mode).toString)</b>
<b class="fc">&nbsp;        case n: SubTypeNode =&gt; TypePlaceholder(n.node.toHtmlLineReadOnly(mode).toString)</b>
<b class="fc">&nbsp;      }</b>
<b class="fc">&nbsp;      prettyPrint(constructor.newInstance(arguments: _*).asInstanceOf[Expr])</b>
&nbsp;    }
&nbsp;
&nbsp;    private def getExprHtmlLineReadOnly(mode: DisplayMode): String = {
<b class="fc">&nbsp;      val constructor = exprClass.getConstructors.head</b>
<b class="fc">&nbsp;      val arguments = lang +: args.map {</b>
<b class="fc">&nbsp;        case n: SubExprNode =&gt; ExprPlaceholder(n.toHtmlLineReadOnly(mode).toString)</b>
<b class="fc">&nbsp;        case n: LiteralNode =&gt; LiteralAny(n.toHtmlLineReadOnly(mode).toString)</b>
<b class="fc">&nbsp;        case n: SubTypeNode =&gt; TypePlaceholder(n.node.toHtmlLineReadOnly(mode).toString)</b>
<b class="fc">&nbsp;      }</b>
<b class="fc">&nbsp;      prettyPrint(constructor.newInstance(arguments: _*).asInstanceOf[Expr])</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    override def toString: String = s&quot;VariableNode(${UtilityFunctions.quote(exprName)}, $args)&quot;</b>
&nbsp;
<b class="fc">&nbsp;    children.foreach(_.setParent(Some(this)))</b>
<b class="fc">&nbsp;    args.foreach(_.setParent(Some(this)))</b>
&nbsp;  }
&nbsp;
<b class="pc">&nbsp;  object VariableNode {</b>
<b class="fc">&nbsp;    def createFromExprName(exprName: String): VariableNode = {</b>
<b class="fc">&nbsp;      val exprClass = exprNameToClass(exprName).get</b>
<b class="fc">&nbsp;      val constructor = exprClass.getConstructors.head</b>
<b class="fc">&nbsp;      val innerNodes = constructor.getParameterTypes</b>
<b class="fc">&nbsp;        .map {</b>
<b class="fc">&nbsp;          case c if classOf[AbstractNodeLanguage] isAssignableFrom c =&gt; None</b>
<b class="fc">&nbsp;          case c if classOf[Expr] isAssignableFrom c                 =&gt; Some(SubExprNode(ExprChoiceNode()))</b>
<b class="fc">&nbsp;          case c if classOf[Literal] isAssignableFrom c              =&gt; Some(LiteralNode(&quot;&quot;))</b>
<b class="fc">&nbsp;          case c if classOf[Type] isAssignableFrom c                 =&gt; Some(SubTypeNode(TypeChoiceNode()))</b>
<b class="nc">&nbsp;          case c =&gt; throw new Exception(s&quot;Unexpected parameter type in createFromExpr: $c&quot;)</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        .filter(_.isDefined)</b>
<b class="fc">&nbsp;        .map(_.get)</b>
<b class="fc">&nbsp;      val result = VariableNode(exprName, innerNodes.toList)</b>
<b class="fc">&nbsp;      innerNodes.foreach(_.setParent(Some(result)))</b>
<b class="fc">&nbsp;      result</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    def fromExpr(e: Expr): ExprNode = e match {</b>
<b class="fc">&nbsp;      case blank: BlankExprDropDown =&gt; ExprChoiceNode()</b>
<b class="fc">&nbsp;      case e =&gt;</b>
<b class="fc">&nbsp;        val exprClass = e.getClass</b>
<b class="fc">&nbsp;        val constructor = exprClass.getConstructors()(0)</b>
<b class="fc">&nbsp;        val innerNodes = e match {</b>
<b class="fc">&nbsp;          case e0: Product =&gt;</b>
<b class="fc">&nbsp;            val values = e0.productIterator.toList</b>
<b class="fc">&nbsp;            values.collect({</b>
<b class="fc">&nbsp;              case c: Expr    =&gt; SubExprNode(VariableNode.fromExpr(c))</b>
<b class="fc">&nbsp;              case c: Literal =&gt; LiteralNode(c.toString)</b>
<b class="fc">&nbsp;              case c: Type    =&gt; SubTypeNode(TypeNode.fromType(c))</b>
<b class="nc">&nbsp;            })</b>
&nbsp;        }
<b class="fc">&nbsp;        val result = VariableNode(e.getClass.getSimpleName, innerNodes)</b>
<b class="fc">&nbsp;        result.overrideExpr(e)</b>
<b class="fc">&nbsp;        innerNodes.foreach(_.setParent(Some(result)))</b>
<b class="fc">&nbsp;        result</b>
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
<b class="pc">&nbsp;  case class ExprChoiceNode() extends ExprNode {</b>
<b class="fc">&nbsp;    override val args: List[InnerNode] = Nil</b>
&nbsp;
<b class="fc">&nbsp;    override val children: List[OuterNode] = Nil</b>
&nbsp;
&nbsp;    override def toHtmlLine(mode: DisplayMode): TypedTag[String] =
<b class="fc">&nbsp;      BlankExprDropDown().toHtml(data(&quot;tree-path&quot;) := treePathString)</b>
&nbsp;
<b class="fc">&nbsp;    override def toHtmlLineReadOnly(mode: DisplayMode): TypedTag[String] = toHtmlLine(mode)(readonly, disabled)</b>
&nbsp;
<b class="fc">&nbsp;    override val exprName: String = &quot;ExprChoice&quot;</b>
&nbsp;
<b class="fc">&nbsp;    override def getExpr: Expr = BlankExprDropDown()</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  abstract class InnerNode extends Node {}</b>
&nbsp;
<b class="pc">&nbsp;  case class SubExprNode(node: ExprNode) extends InnerNode {</b>
<b class="fc">&nbsp;    override def setParent(parentNode: Option[OuterNode]): Unit = parentNode match {</b>
<b class="fc">&nbsp;      case Some(n: ExprNode) =&gt; super.setParent(Some(n))</b>
<b class="fc">&nbsp;      case None              =&gt; throw new InnerNodeCannotBeRootException()</b>
<b class="fc">&nbsp;      case Some(n)           =&gt; throw new NodeParentWrongTypeException(classOf[ExprNode], n.getClass)</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    override def getParent: Option[ExprNode] = super.getParent match {</b>
<b class="fc">&nbsp;      case Some(n: ExprNode) =&gt; Some(n)</b>
<b class="nc">&nbsp;      case None              =&gt; None</b>
<b class="nc">&nbsp;      case Some(n)           =&gt; throw new NodeParentWrongTypeException(classOf[ExprNode], n.getClass)</b>
&nbsp;    }
&nbsp;
&nbsp;    override def toHtmlLine(mode: DisplayMode): TypedTag[String] =
<b class="fc">&nbsp;      node.toHtmlLineReadOnly(mode)</b>
&nbsp;
<b class="fc">&nbsp;    override def toHtmlLineReadOnly(mode: DisplayMode): TypedTag[String] = toHtmlLine(mode)</b>
&nbsp;
<b class="fc">&nbsp;    override val children: List[ExprNode] = List(node)</b>
&nbsp;  }
&nbsp;
<b class="pc">&nbsp;  case class LiteralNode(literalText: String) extends InnerNode {</b>
<b class="fc">&nbsp;    private val htmlLineShared: TypedTag[String] = input(`type` := &quot;text&quot;, cls := &quot;literal&quot;, value := literalText)</b>
&nbsp;
&nbsp;    override def toHtmlLine(mode: DisplayMode): TypedTag[String] =
<b class="fc">&nbsp;      htmlLineShared(width := Math.max(2, literalText.length) + &quot;ch&quot;, data(&quot;tree-path&quot;) := treePathString)</b>
&nbsp;
&nbsp;    override def toHtmlLineReadOnly(mode: DisplayMode): TypedTag[String] =
<b class="fc">&nbsp;      htmlLineShared(width := Math.max(1, literalText.length) + &quot;ch&quot;, readonly, disabled)</b>
&nbsp;
<b class="fc">&nbsp;    override val children: List[OuterNode] = Nil</b>
&nbsp;
<b class="fc">&nbsp;    override def toString: String = s&quot;LiteralNode(${UtilityFunctions.quote(literalText)})&quot;</b>
&nbsp;
<b class="fc">&nbsp;    lazy val getLiteral: Literal = Literal.fromString(literalText)</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  abstract class TypeNodeParent extends OuterNode {</b>
&nbsp;    lazy val getType: Type
&nbsp;
<b class="fc">&nbsp;    lazy val getTypeName: String = getType.getClass.getSimpleName</b>
&nbsp;
&nbsp;    override def getParent: Option[OuterNode] = {
<b class="fc">&nbsp;      if (!isParentInitialised) markRoot()</b>
<b class="fc">&nbsp;      super.getParent match {</b>
<b class="fc">&nbsp;        case Some(n) =&gt; Some(n)</b>
<b class="fc">&nbsp;        case None    =&gt; None</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    def toHtmlAxiom(mode: DisplayMode): TypedTag[String] = {
<b class="fc">&nbsp;      div(</b>
<b class="fc">&nbsp;        cls := &quot;subtree axiom&quot;,</b>
<b class="fc">&nbsp;        data(&quot;tree-path&quot;) := treePathString,</b>
<b class="fc">&nbsp;        data(&quot;node-string&quot;) := toString,</b>
<b class="fc">&nbsp;        div(cls := &quot;expr&quot;, toHtmlLine(mode)(display := &quot;inline&quot;)),</b>
<b class="fc">&nbsp;        div(cls := &quot;annotation-axiom&quot;, getTypeName)</b>
&nbsp;      )
&nbsp;    }
&nbsp;
&nbsp;    def toHtmlSubtree(mode: DisplayMode): TypedTag[String] = {
<b class="fc">&nbsp;      div(</b>
<b class="fc">&nbsp;        cls := &quot;subtree&quot;,</b>
<b class="fc">&nbsp;        data(&quot;tree-path&quot;) := treePathString,</b>
<b class="fc">&nbsp;        data(&quot;node-string&quot;) := toString,</b>
<b class="fc">&nbsp;        div(cls := &quot;node&quot;, div(cls := &quot;expr&quot;, toHtmlLine(mode))),</b>
<b class="fc">&nbsp;        div(cls := &quot;args&quot;, children.map(_.toHtml(mode)), div(cls := &quot;annotation-new&quot;, getTypeName))</b>
&nbsp;      )
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  case class TypeNode(typeName: String, args: List[InnerNode]) extends TypeNodeParent {</b>
<b class="fc">&nbsp;    override lazy val getType: Type = {</b>
<b class="fc">&nbsp;      val constructor = typeClass.getConstructors()(0)</b>
<b class="fc">&nbsp;      val arguments = lang +: args.map {</b>
<b class="fc">&nbsp;        case tn: SubTypeNode =&gt; tn.node.getType</b>
<b class="nc">&nbsp;        case ln: LiteralNode =&gt; ln.getLiteral</b>
<b class="fc">&nbsp;      }</b>
<b class="fc">&nbsp;      constructor.newInstance(arguments: _*).asInstanceOf[Type]</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    private lazy val typeClass: Class[Type] = typeNameToClass(typeName) match {</b>
<b class="fc">&nbsp;      case Some(value) =&gt; value</b>
<b class="fc">&nbsp;      case None =&gt;</b>
<b class="fc">&nbsp;        throw new IllegalArgumentException(s&quot;Unknown expression type for ${lang.getClass.getSimpleName}: $typeName&quot;)</b>
&nbsp;    }
&nbsp;
&nbsp;    override def toHtmlLine(mode: DisplayMode): TypedTag[String] =
<b class="fc">&nbsp;      getType.toHtml(data(&quot;tree-path&quot;) := treePathString)</b>
&nbsp;
&nbsp;    override def toHtmlLineReadOnly(mode: DisplayMode): TypedTag[String] =
<b class="fc">&nbsp;      toHtmlLine(mode)(readonly, disabled)</b>
&nbsp;
<b class="fc">&nbsp;    override val children: List[OuterNode] = args.filter(_.isInstanceOf[SubTypeNode]).flatMap(_.children)</b>
&nbsp;
<b class="fc">&nbsp;    override def toString: String = s&quot;TypeNode(${UtilityFunctions.quote(typeName)}, $args)&quot;</b>
&nbsp;
&nbsp;    def getExprHtmlLine(mode: DisplayMode): String = {
<b class="nc">&nbsp;      val constructor = typeClass.getConstructors()(0)</b>
<b class="nc">&nbsp;      val arguments = lang +: args.map {</b>
<b class="nc">&nbsp;        case n: LiteralNode =&gt; LiteralAny(n.toHtmlLine(mode).toString)</b>
<b class="nc">&nbsp;        case n: SubTypeNode =&gt; TypePlaceholder(n.node.toHtmlLine(mode).toString)</b>
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;      prettyPrint(constructor.newInstance(arguments: _*).asInstanceOf[Expr])</b>
&nbsp;    }
&nbsp;
&nbsp;    def getExprHtmlLineReadOnly(mode: DisplayMode): String = {
<b class="nc">&nbsp;      val constructor = typeClass.getConstructors()(0)</b>
<b class="nc">&nbsp;      val arguments = lang +: args.map {</b>
<b class="nc">&nbsp;        case n: LiteralNode =&gt; LiteralAny(n.toHtmlLineReadOnly(mode).toString)</b>
<b class="nc">&nbsp;        case n: SubTypeNode =&gt; TypePlaceholder(n.node.toHtmlLineReadOnly(mode).toString)</b>
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;      prettyPrint(constructor.newInstance(arguments: _*).asInstanceOf[Expr])</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    children.foreach(_.setParent(Some(this)))</b>
<b class="fc">&nbsp;    args.foreach(_.setParent(Some(this)))</b>
&nbsp;  }
&nbsp;
<b class="pc">&nbsp;  object TypeNode {</b>
<b class="fc">&nbsp;    def fromTypeName(typeName: String): TypeNode = {</b>
<b class="fc">&nbsp;      typeNameToClass(typeName) match {</b>
<b class="fc">&nbsp;        case Some(typ) =&gt;</b>
<b class="fc">&nbsp;          val constructor = typ.getConstructors()(0)</b>
<b class="fc">&nbsp;          val arguments = constructor.getParameterTypes</b>
<b class="fc">&nbsp;            .map({</b>
<b class="fc">&nbsp;              case c if classOf[Type] isAssignableFrom c             =&gt; Some(SubTypeNode(TypeChoiceNode()))</b>
<b class="fc">&nbsp;              case c if classOf[Literal] isAssignableFrom c          =&gt; Some(LiteralNode(&quot;&quot;))</b>
<b class="fc">&nbsp;              case c if classOf[AbstractLanguage] isAssignableFrom c =&gt; None</b>
<b class="fc">&nbsp;            })</b>
<b class="fc">&nbsp;            .filter(_.isDefined)</b>
<b class="fc">&nbsp;            .map(_.get)</b>
&nbsp;            .toList
<b class="fc">&nbsp;          TypeNode(typeName, arguments)</b>
<b class="nc">&nbsp;        case None =&gt;</b>
<b class="nc">&nbsp;          throw new IllegalArgumentException(s&quot;Unknown expression type for ${lang.getClass.getSimpleName}: $typeName&quot;)</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    def fromType(typ: Type): TypeNodeParent = typ match {</b>
<b class="fc">&nbsp;      case blank: BlankTypeDropDown =&gt; TypeChoiceNode()</b>
&nbsp;      case _ =&gt;
<b class="fc">&nbsp;        val typeClass = typ.getClass</b>
<b class="fc">&nbsp;        val constructor = typeClass.getConstructors()(0)</b>
<b class="fc">&nbsp;        val innerNodes = typ match {</b>
<b class="fc">&nbsp;          case e0: Product =&gt;</b>
<b class="fc">&nbsp;            val values = e0.productIterator.toList</b>
<b class="fc">&nbsp;            values.collect({</b>
<b class="fc">&nbsp;              case c: Literal =&gt; LiteralNode(c.toString)</b>
<b class="fc">&nbsp;              case c: Type    =&gt; SubTypeNode(TypeNode.fromType(c))</b>
<b class="nc">&nbsp;            })</b>
&nbsp;        }
<b class="fc">&nbsp;        val result = TypeNode(typ.getClass.getSimpleName, innerNodes)</b>
<b class="fc">&nbsp;        innerNodes.foreach(_.setParent(Some(result)))</b>
<b class="fc">&nbsp;        result</b>
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
<b class="pc">&nbsp;  case class TypeChoiceNode() extends TypeNodeParent {</b>
<b class="fc">&nbsp;    override val args: List[InnerNode] = Nil</b>
&nbsp;
&nbsp;    override def toHtmlLine(mode: DisplayMode): TypedTag[String] =
<b class="fc">&nbsp;      BlankTypeDropDown().toHtml(data(&quot;tree-path&quot;) := treePathString)</b>
&nbsp;
<b class="fc">&nbsp;    override def toHtmlLineReadOnly(mode: DisplayMode): TypedTag[String] = toHtmlLine(mode)(readonly, disabled)</b>
&nbsp;
<b class="fc">&nbsp;    override lazy val getType: Type = UnknownType()</b>
&nbsp;  }
&nbsp;
<b class="pc">&nbsp;  case class SubTypeNode(node: TypeNodeParent) extends InnerNode {</b>
<b class="fc">&nbsp;    override val children: List[OuterNode] = List(node)</b>
&nbsp;
<b class="nc">&nbsp;    override def toHtmlLine(mode: DisplayMode): TypedTag[String] = node.toHtmlLineReadOnly(mode)</b>
&nbsp;
<b class="fc">&nbsp;    override def toHtmlLineReadOnly(mode: DisplayMode): TypedTag[String] = toHtmlLine(mode)(readonly, disabled)</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  private val depthLimit: Int = 100</b>
&nbsp;
<b class="fc">&nbsp;  class DepthLimitExceededException extends Exception(s&quot;Depth limit ($depthLimit) exceeded&quot;)</b>
&nbsp;
<b class="fc">&nbsp;  class InvalidTreePathStringException(s: String) extends Exception(s&quot;Invalid tree path string: $s&quot;)</b>
&nbsp;
<b class="fc">&nbsp;  class InvalidTreePathException(treePath: List[Int]) extends Exception(s&quot;Invalid tree path: $treePath&quot;)</b>
&nbsp;
<b class="fc">&nbsp;  class NodeStringParseException(nodeString: String) extends Exception(s&quot;Could not parse node string: $nodeString&quot;)</b>
&nbsp;
<b class="nc">&nbsp;  class NodeParentNotInitialisedException extends Exception(&quot;Node parent not initialised&quot;)</b>
&nbsp;
<b class="fc">&nbsp;  class NodeParentWrongTypeException(expected: Class[_ &lt;: OuterNode], actual: Class[_ &lt;: OuterNode])</b>
<b class="fc">&nbsp;      extends Exception(s&quot;Node parent has wrong type: expected $expected, got $actual&quot;)</b>
&nbsp;
<b class="fc">&nbsp;  class InnerNodeCannotBeRootException extends Exception(&quot;Inner node cannot be root&quot;)</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-01-21 10:10</div>
</div>
</body>
</html>
